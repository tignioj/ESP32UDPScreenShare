#ifndef MY_SCALE_FUNCTION_H // 如果宏 MY_HEADER_H 没有被定义
#define MY_SCALE_FUNCTION_H // 那么定义这个宏，并编译下面的内容

#include <stdint.h>


// ================= RGB332 → RGB565 =================
static inline uint16_t rgb332_to_rgb565(uint8_t c)
{
    return ((c & 0xE0) << 8) |   // R: 3 → 5
           ((c & 0x1C) << 6) |   // G: 3 → 6
           ((c & 0x03) << 3);    // B: 2 → 5
}
// ================= RGB332 → RGB565LUT =================
// 更高效的颜色转换
// 由python自动生成
/*
def rgb332_to_565(c):
    return ((c & 0xE0) << 8) | ((c & 0x1C) << 6) | ((c & 0x03) << 3)

for i in range(256):
    print(f"0x{rgb332_to_565(i):04X},", end="")
    if (i + 1) % 8 == 0:
        print()
*/
static const uint16_t rgb332_to_565_lut[256] = {
0x0000,0x0008,0x0010,0x0018,0x0100,0x0108,0x0110,0x0118,
0x0200,0x0208,0x0210,0x0218,0x0300,0x0308,0x0310,0x0318,
0x0400,0x0408,0x0410,0x0418,0x0500,0x0508,0x0510,0x0518,
0x0600,0x0608,0x0610,0x0618,0x0700,0x0708,0x0710,0x0718,
0x2000,0x2008,0x2010,0x2018,0x2100,0x2108,0x2110,0x2118,
0x2200,0x2208,0x2210,0x2218,0x2300,0x2308,0x2310,0x2318,
0x2400,0x2408,0x2410,0x2418,0x2500,0x2508,0x2510,0x2518,
0x2600,0x2608,0x2610,0x2618,0x2700,0x2708,0x2710,0x2718,
0x4000,0x4008,0x4010,0x4018,0x4100,0x4108,0x4110,0x4118,
0x4200,0x4208,0x4210,0x4218,0x4300,0x4308,0x4310,0x4318,
0x4400,0x4408,0x4410,0x4418,0x4500,0x4508,0x4510,0x4518,
0x4600,0x4608,0x4610,0x4618,0x4700,0x4708,0x4710,0x4718,
0x6000,0x6008,0x6010,0x6018,0x6100,0x6108,0x6110,0x6118,
0x6200,0x6208,0x6210,0x6218,0x6300,0x6308,0x6310,0x6318,
0x6400,0x6408,0x6410,0x6418,0x6500,0x6508,0x6510,0x6518,
0x6600,0x6608,0x6610,0x6618,0x6700,0x6708,0x6710,0x6718,
0x8000,0x8008,0x8010,0x8018,0x8100,0x8108,0x8110,0x8118,
0x8200,0x8208,0x8210,0x8218,0x8300,0x8308,0x8310,0x8318,
0x8400,0x8408,0x8410,0x8418,0x8500,0x8508,0x8510,0x8518,
0x8600,0x8608,0x8610,0x8618,0x8700,0x8708,0x8710,0x8718,
0xA000,0xA008,0xA010,0xA018,0xA100,0xA108,0xA110,0xA118,
0xA200,0xA208,0xA210,0xA218,0xA300,0xA308,0xA310,0xA318,
0xA400,0xA408,0xA410,0xA418,0xA500,0xA508,0xA510,0xA518,
0xA600,0xA608,0xA610,0xA618,0xA700,0xA708,0xA710,0xA718,
0xC000,0xC008,0xC010,0xC018,0xC100,0xC108,0xC110,0xC118,
0xC200,0xC208,0xC210,0xC218,0xC300,0xC308,0xC310,0xC318,
0xC400,0xC408,0xC410,0xC418,0xC500,0xC508,0xC510,0xC518,
0xC600,0xC608,0xC610,0xC618,0xC700,0xC708,0xC710,0xC718,
0xE000,0xE008,0xE010,0xE018,0xE100,0xE108,0xE110,0xE118,
0xE200,0xE208,0xE210,0xE218,0xE300,0xE308,0xE310,0xE318,
0xE400,0xE408,0xE410,0xE418,0xE500,0xE508,0xE510,0xE518,
0xE600,0xE608,0xE610,0xE618,0xE700,0xE708,0xE710,0xE718
};

// ================= 放大函数 =================

// 预计算映射表
static int scale_x_map[240];  // 水平映射表
static int scale_y_map[240];  // 垂直映射表（最大支持240行）
// 初始化映射表（在setup中调用）
void init_scale_maps() {
    // 计算水平映射
    for (int dst_x = 0; dst_x < 240; dst_x++) {
        scale_x_map[dst_x] = (dst_x * 180 + 120) / 240;  // 四舍五入
        if (scale_x_map[dst_x] >= 180) {
            scale_x_map[dst_x] = 179;
        }
    }
    
    // 计算垂直映射（最大240行）
    for (int dst_y = 0; dst_y < 240; dst_y++) {
        scale_y_map[dst_y] = (dst_y * 180 + 120) / 240;  // 四舍五入
        if (scale_y_map[dst_y] >= 180) {
            scale_y_map[dst_y] = 179;
        }
    }
}
// 最近邻插值放大 180→240 (放大系数 1.333:1)
// 使用映射表的缩放函数
static void scale_180_to_240_table(const uint8_t* src, uint16_t* dst, bool is_rgb565, int src_lines)
{
    // 计算目标行数
    int dst_lines = (src_lines * 240 + 179) / 180;
    
    for (int dst_y = 0; dst_y < dst_lines; dst_y++) {
        // 使用预计算的映射表
        int src_y = scale_y_map[dst_y];
        
        // 确保不越界
        if (src_y >= src_lines) {
            src_y = src_lines - 1;
        }
        
        for (int dst_x = 0; dst_x < 240; dst_x++) {
            int src_x = scale_x_map[dst_x];
            
            if (is_rgb565) {
                dst[dst_y * 240 + dst_x] = ((uint16_t*)src)[src_y * 180 + src_x];
            } else {
                dst[dst_y * 240 + dst_x] = rgb332_to_rgb565(src[src_y * 180 + src_x]);
            }
        }
    }
}
// 最近邻插值放大 120→240 (放大系数 2:1)
static void scale_120_to_240(const uint8_t* src, uint16_t* dst, bool is_rgb565, int src_lines)
{

    // 目标行数 = 源行数 * 2
    int dst_lines = src_lines * 2;
    // 简单复制: 每个源像素变成 2x2 个目标像素
    for (int src_y = 0; src_y < src_lines; src_y++) {
        int dst_y = src_y * 2;

        // 确保不超出目标缓冲区
        if (dst_y + 1 >= dst_lines) continue;
        for (int src_x = 0; src_x < 120; src_x++) {
            int dst_x = src_x * 2;
            
            uint16_t pixel;
            if (is_rgb565) {
                pixel = ((uint16_t*)src)[src_y * 120 + src_x];
            } else {
                pixel = rgb332_to_rgb565(src[src_y * 120 + src_x]);
            }
            
            // 填充 2x2 像素块
            dst[dst_y * 240 + dst_x] = pixel;
            dst[dst_y * 240 + dst_x + 1] = pixel;
            dst[(dst_y + 1) * 240 + dst_x] = pixel;
            dst[(dst_y + 1) * 240 + dst_x + 1] = pixel;
        }
    }
}

#endif MY_SCALE_FUNCTION_H