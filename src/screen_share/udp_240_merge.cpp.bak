#include <WiFi.h>
#include <WiFiUdp.h>
#include "common.h"

// ================= WiFi =================
const char* ssid = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;

WiFiUDP udp;
#define UDP_PORT 8888
// ================= Image =================
#define IMG_W 240

// #define RGB_LINE_BATCH 8  // 180 rgb332
#define RGB_LINE_BATCH 6  // 240 rgb332 | 120 rgb565
// #define RGB_LINE_BATCH 4  // 180 rgb565 | 240 rgb332
// #define RGB_LINE_BATCH 3  // 240 rgb565

// ================= Frame Buffer =================
#define FRAME_BUF_COUNT 8

enum BufState {
    BUF_FREE,
    BUF_FILLING,
    BUF_READY,
    BUF_DISPLAYING
};

struct FrameData {
    uint16_t y_start;
    uint16_t line_count;
    uint16_t lines[RGB_LINE_BATCH * IMG_W];
    volatile BufState state;
};

FrameData frameBuf[FRAME_BUF_COUNT];

// ================= DMA =================
uint16_t* dmaBuf[2];
volatile uint8_t dmaSel = 0;

// ================= Stats =================
volatile uint32_t frameCount = 0;
volatile uint32_t dropCount  = 0;
volatile uint32_t udpPackets = 0;

// ================= RGB332 → RGB565 =================
static inline uint16_t rgb332_to_rgb565(uint8_t c)
{
    return ((c & 0xE0) << 8) |   // R: 3 → 5
           ((c & 0x1C) << 6) |   // G: 3 → 6
           ((c & 0x03) << 3);    // B: 2 → 5
}

// ================= UDP Receiver Task =================
void udpReceiverTask(void* param) {
    while (1) {
        // 确保每次循环都清理干净
        // while (udp.available() > 0) {
        //     udp.read();
        // }
        // 记录接收到的数据包大小用于调试
        // Serial.printf("Received packet size: %d\n", packetSize);
        int packetSize = udp.parsePacket();
        if (packetSize <= 0) {
            vTaskDelay(1);
            continue;
        }
        udpPackets++;
        uint8_t header[5];
        if (udp.read(header, 5) != 5) {
            udp.flush();
            continue;
        }

        // 解析 frame_id / y_start
        uint16_t frame_id = (header[0] << 8) | header[1];
        uint16_t y_start  = (header[2] << 8) | header[3];

        // 解析 flags（重点）
        uint8_t flags = header[4];

        uint8_t resolution = (flags >> 6) & 0b11;
        uint8_t color_mode = (flags >> 4) & 0b11;
        uint8_t line_count = flags & 0b1111;

        uint16_t img_w, img_h;

        switch (resolution) {
            case 0: img_w = img_h = 240; break;
            case 1: img_w = img_h = 180; break;
            case 2: img_w = img_h = 120; break;
            default: {
                udp.flush();
                Serial.println("分辨率不合理!"); continue;
            }; // 非法
        }

        bool is_rgb565 = (color_mode == 0);
        // Serial.printf("res=%d, color=%d, linecount=%d, imgwh=%d\n", resolution,color_mode,line_count, img_w);
        
        if (line_count == 0 || line_count > RGB_LINE_BATCH) {
            udp.flush();
            continue;
        }

        uint32_t bytes_per_pixel = is_rgb565 ? 2 : 1;
        uint32_t expect = IMG_W * line_count * bytes_per_pixel;

        // 找 FREE buffer
        FrameData* f = nullptr;
        for (int i = 0; i < FRAME_BUF_COUNT; i++) {
            if (frameBuf[i].state == BUF_FREE) {
                f = &frameBuf[i];
                f->state = BUF_FILLING;
                if(i>5) Serial.printf("%d正在装填\n",i);
                break;
            }
        }

        if (!f) {
            // 没 FREE，丢包
            dropCount++;
            udp.flush();
            Serial.println("没有空闲的Buffer");
            continue;
        }

        static uint8_t rxBuf[IMG_W * RGB_LINE_BATCH * 2];
        if (udp.read(rxBuf, expect) != expect) {
            f->state = BUF_FREE;
            continue;
        }

        // 转换 RGB332 → RGB565
        if (is_rgb565) {
            memcpy(f->lines, rxBuf, IMG_W * line_count * 2);
        } else {
            uint32_t px = IMG_W * line_count;
            for (uint32_t i = 0; i < px; i++) {
                f->lines[i] = rgb332_to_rgb565(rxBuf[i]);
            }
        }

        f->y_start = y_start;
        f->line_count = line_count;
        f->state = BUF_READY;
    }
}

// ================= Draw Frame =================
void drawFrame() {
    FrameData* newest = nullptr;
    int newestIdx = -1;

    // 
    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        if (frameBuf[i].state == BUF_READY) {
            newest = &frameBuf[i];
            newestIdx = i;
            break;
        }
    }

    if (!newest) return;

    // // 其余 READY 的直接丢弃（防堆积）
    // for (int i = 0; i < FRAME_BUF_COUNT; i++) {
    //     if (i != newestIdx && frameBuf[i].state == BUF_READY) {
    //         frameBuf[i].state = BUF_FREE;
    //         dropCount++;
    //         // Serial.printf("%d堆积的全部Free掉",i);
    //     }
    // }

    newest->state = BUF_DISPLAYING;

    uint8_t nextDma = dmaSel ^ 1;

    // 只在切换 DMA buffer 时等待
    tft->dmaWait();

    memcpy(
        dmaBuf[nextDma],
        newest->lines,
        IMG_W * newest->line_count * 2
    );

    tft->startWrite();
    tft->pushImageDMA(
        0,
        newest->y_start,
        IMG_W,
        newest->line_count,
        dmaBuf[nextDma]
    );
    tft->endWrite();

    dmaSel = nextDma;
    newest->state = BUF_FREE;
    frameCount++;
}

// ================= Setup =================
void setup() {
    Serial.begin(115200);

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(300);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected");

    udp.begin(UDP_PORT);

    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        frameBuf[i].state = BUF_FREE;
    }

    screen.init(4, 100);
    tft->initDMA();
    tft->setSwapBytes(true);


    dmaBuf[0] = (uint16_t*)heap_caps_malloc(
        IMG_W * RGB_LINE_BATCH * 2,
        MALLOC_CAP_DMA
    );
    dmaBuf[1] = (uint16_t*)heap_caps_malloc(
        IMG_W * RGB_LINE_BATCH * 2,
        MALLOC_CAP_DMA
    );

    if (!dmaBuf[0] || !dmaBuf[1]) {
        Serial.println("DMA alloc failed");
        while (1);
    }

    xTaskCreatePinnedToCore(
        udpReceiverTask,
        "udp_rx",
        8192,
        nullptr,
        2,
        nullptr,
        0
    );
    tft->fillScreen(TFT_BLACK);
}
// ------------------------- 调试信息打印 -------------------------
void printDebugInfo() {
    static uint32_t lastPrint = 0;
    uint32_t now = millis();
    
    if (now - lastPrint > 1000) {
        lastPrint = now;
        
        Serial.printf("内存: %u, ", ESP.getFreeHeap());
        Serial.printf("UDP包/秒: %u, ", udpPackets);
        Serial.printf("丢包数: %u, ", dropCount);
        Serial.printf("显示帧数: %u, ", frameCount);
        
        // 显示缓冲区状态
        Serial.print("缓冲区状态: ");
        for (int i = 0; i < FRAME_BUF_COUNT; i++) {
            switch(frameBuf[i].state) {
                case BUF_FREE: Serial.print("F"); break;
                case BUF_FILLING: Serial.print("I"); break;
                case BUF_READY: Serial.print("R"); break;
                case BUF_DISPLAYING: Serial.print("D"); break;
            }
        }
        Serial.println();
        
        udpPackets = 0;
    }
}
// ================= Loop =================
void loop() {
    // screen.routine();
    drawFrame();

    printDebugInfo();
}
