#include <WiFi.h>
#include <WiFiUdp.h>
#include "common.h"

// ================= WiFi =================
const char* ssid     = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;

WiFiUDP udp;
#define UDP_PORT 8888

// ================= Image =================
#define SRC_W 180
#define SRC_H 180

#define DST_W 240
#define DST_H 240

#define RGB_LINE_BATCH 4

// 180 -> 240，最大放大比例 4/3
#define MAX_DST_LINES ((RGB_LINE_BATCH * 4 + 2) / 3)

// ================= Frame Buffer =================
#define FRAME_BUF_COUNT 12  // 中等数量的缓冲区

enum BufState {
    BUF_FREE,
    BUF_FILLING,
    BUF_READY,
    BUF_DISPLAYING
};

// 存储放大后的数据
struct FrameData {
    uint16_t y_start;    // 目标图像 y（0~239）
    uint16_t line_count; // 目标行数 <= MAX_DST_LINES
    uint16_t lines[MAX_DST_LINES * DST_W]; // 存储放大后的数据
    volatile BufState state;
};

FrameData frameBuf[FRAME_BUF_COUNT];

// ================= DMA =================
uint16_t* dmaBuf[2];
volatile uint8_t dmaSel = 0;

// ================= Stats =================
volatile uint32_t frameCount = 0;
volatile uint32_t dropCount  = 0;
volatile uint32_t udpPackets = 0;
volatile uint32_t udpBytes = 0;

// ================= Utils =================
// 快速缩放函数 - 使用查表法实现最近邻插值
void fastScaleLines(uint16_t* dst, const uint16_t* src, int srcY0, int srcLines) {
    static uint8_t x_map[DST_W];  // x坐标映射表
    static uint8_t y_map[MAX_DST_LINES]; // y坐标映射表
    static bool tables_initialized = false;
    
    if (!tables_initialized) {
        // 初始化x映射表
        for (int x = 0; x < DST_W; x++) {
            // x * 180 / 240 简化为 x * 3 / 4
            x_map[x] = (x * 3) >> 2;
        }
        
        // 初始化y映射表
        for (int dy = 0; dy < MAX_DST_LINES; dy++) {
            // 计算目标y对应的源y（相对于srcY0）
            int srcY = ((dy * 3) >> 2);
            if (srcY >= srcLines) srcY = srcLines - 1;
            y_map[dy] = srcY;
        }
        tables_initialized = true;
    }
    
    // 计算目标行数
    int dstY0 = (srcY0 * 4) / 3;
    int dstY1 = ((srcY0 + srcLines) * 4 + 2) / 3;
    int dstLines = dstY1 - dstY0;
    if (dstLines > MAX_DST_LINES) dstLines = MAX_DST_LINES;
    
    // 并行处理多个像素（展开循环）
    for (int dy = 0; dy < dstLines; dy++) {
        const uint16_t* srcLine = src + y_map[dy] * SRC_W;
        uint16_t* dstLine = dst + dy * DST_W;
        
        // 展开循环以提高速度（一次处理4个像素）
        int x;
        for (x = 0; x < DST_W - 3; x += 4) {
            uint8_t sx1 = x_map[x];
            uint8_t sx2 = x_map[x+1];
            uint8_t sx3 = x_map[x+2];
            uint8_t sx4 = x_map[x+3];
            
            dstLine[x]   = srcLine[sx1];
            dstLine[x+1] = srcLine[sx2];
            dstLine[x+2] = srcLine[sx3];
            dstLine[x+3] = srcLine[sx4];
        }
        
        // 处理剩余像素
        for (; x < DST_W; x++) {
            dstLine[x] = srcLine[x_map[x]];
        }
    }
}

// ================= UDP Receiver Task =================
void udpReceiverTask(void* param) {
    while (1) {
        int packetSize = udp.parsePacket();
        if (packetSize <= 0) {
            vTaskDelay(1);
            continue;
        }
        
        udpPackets++;
        
        uint8_t header[6];
        if (udp.read(header, 6) != 6) {
            udp.flush();
            continue;
        }

        uint16_t y_start    = (header[2] << 8) | header[3];
        uint16_t line_count = (header[4] << 8) | header[5];

        if (line_count == 0 || line_count > RGB_LINE_BATCH) {
            udp.flush();
            continue;
        }

        uint32_t expect = SRC_W * line_count * 2;
        
        // 查找空闲缓冲区
        FrameData* f = nullptr;
        int freeIdx = -1;
        
        for (int i = 0; i < FRAME_BUF_COUNT; i++) {
            if (frameBuf[i].state == BUF_FREE) {
                f = &frameBuf[i];
                freeIdx = i;
                f->state = BUF_FILLING;
                break;
            }
        }
        
        if (!f) {
            // 如果没有空闲缓冲区，尝试覆盖一个READY状态的缓冲区
            for (int i = 0; i < FRAME_BUF_COUNT; i++) {
                if (frameBuf[i].state == BUF_READY) {
                    f = &frameBuf[i];
                    freeIdx = i;
                    f->state = BUF_FILLING;
                    dropCount++; // 记录覆盖的帧
                    break;
                }
            }
        }
        
        if (!f) {
            dropCount++;
            udp.flush();
            continue;
        }
        
        // 读取原始数据到临时缓冲区
        uint16_t rawData[RGB_LINE_BATCH * SRC_W];
        
        if (udp.read((uint8_t*)rawData, expect) != expect) {
            f->state = BUF_FREE;
            continue;
        }
        
        udpBytes += expect + 6;
        
        // 在UDP线程中进行快速像素放大
        fastScaleLines(f->lines, rawData, y_start, line_count);
        
        // 计算放大后的目标位置
        int dstY0 = (y_start * 4) / 3;
        int dstY1 = ((y_start + line_count) * 4 + 2) / 3;
        int dstLines = dstY1 - dstY0;
        
        f->y_start = dstY0;
        f->line_count = (dstLines > MAX_DST_LINES) ? MAX_DST_LINES : dstLines;
        f->state = BUF_READY;
    }
}

// ================= Draw Frame =================
void drawFrame() {
    // 查找最新的READY缓冲区
    FrameData* f = nullptr;
    int latestIdx = -1;
    
    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        if (frameBuf[i].state == BUF_READY) {
            // 找到y_start最大的（最新的）缓冲区
            if (f == nullptr || frameBuf[i].y_start > f->y_start) {
                f = &frameBuf[i];
                latestIdx = i;
            }
        }
    }
    
    if (!f) return;
    
    f->state = BUF_DISPLAYING;
    
    // 等待DMA完成
    tft->dmaWait();
    
    // 直接使用放大后的数据
    tft->startWrite();
    tft->pushImageDMA(
        0,
        f->y_start,
        DST_W,
        f->line_count,
        f->lines
    );
    tft->endWrite();
    
    f->state = BUF_FREE;
    frameCount++;
}

// ================= Setup =================
void setup() {
    Serial.begin(115200);

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(300);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected");

    udp.begin(UDP_PORT);

    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        frameBuf[i].state = BUF_FREE;
    }

    screen.init(4, 100);
    tft->initDMA();
    tft->fillScreen(TFT_BLACK);
    tft->setSwapBytes(true);

    // 分配DMA缓冲区（备用）
    dmaBuf[0] = (uint16_t*)heap_caps_malloc(
        DST_W * MAX_DST_LINES * sizeof(uint16_t),
        MALLOC_CAP_DMA
    );
    dmaBuf[1] = (uint16_t*)heap_caps_malloc(
        DST_W * MAX_DST_LINES * sizeof(uint16_t),
        MALLOC_CAP_DMA
    );

    if (!dmaBuf[0] || !dmaBuf[1]) {
        Serial.println("DMA alloc failed");
        while (1);
    }

    xTaskCreatePinnedToCore(
        udpReceiverTask,
        "udp_rx",
        8192,
        nullptr,
        2,
        nullptr,
        0
    );
}

void printDebugInfo() {
    static uint32_t lastPrint = 0;
    uint32_t now = millis();
    
    if (now - lastPrint > 1000) {
        lastPrint = now;
        
        // 统计缓冲区状态
        int freeCount = 0, fillingCount = 0, readyCount = 0, displayingCount = 0;
        
        for (int i = 0; i < FRAME_BUF_COUNT; i++) {
            switch(frameBuf[i].state) {
                case BUF_FREE: freeCount++; break;
                case BUF_FILLING: fillingCount++; break;
                case BUF_READY: readyCount++; break;
                case BUF_DISPLAYING: displayingCount++; break;
            }
        }
        
        Serial.printf("内存: %u, ", ESP.getFreeHeap());
        Serial.printf("UDP包/秒: %u, ", udpPackets);
        Serial.printf("UDP数据: %.1fKB/s, ", udpBytes / 1024.0);
        Serial.printf("丢包: %u, ", dropCount);
        Serial.printf("显示帧: %u, ", frameCount);
        Serial.printf("缓冲区: F%d/I%d/R%d/D%d\n", 
                     freeCount, fillingCount, readyCount, displayingCount);
        
        udpPackets = 0;
        udpBytes = 0;
    }
}

// ================= Loop =================
void loop() {
    drawFrame();
    printDebugInfo();
    // 短暂延时，避免过于频繁循环
    delayMicroseconds(100);
}