#include <WiFi.h>
#include <WiFiUdp.h>
#include "common.h"
#include "screen_share_gui.h"

// WiFi配置
const char* ssid     = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;

WiFiUDP udp;
#define UDP_PORT 8888
#define RGB_LINE_BATCH 6   // 每次接收行数

// 图像参数
#define IMG_W 120
#define IMG_H 120

// ------------------------- 双缓冲结构 -------------------------
struct FrameData {
    uint16_t y_start;           // 原始行索引 * 2
    uint16_t line_count;        // 放大后高度，每原行重复两行
    uint16_t lines[RGB_LINE_BATCH * 2 * IMG_W]; // 240宽，每行放大两倍
};

FrameData frameBuffers[2];       // 双缓冲区
volatile bool frameReady[2] = {false, false};
volatile uint8_t currentBuf = 0; // 0或1

// 在全局或结构体中定义
uint16_t scaledLineBuffer[2][240]; // 双缓冲行缓存，每行240像素
bool lineBufferReady[2] = {false, false};
int currentLineBuffer = 0;
// ------------------------- 全局运行数据 -------------------------
struct ScreenShareAppRunData
{
    uint16_t *displayBufWithDma[2];
    bool dmaBufferSel;
    unsigned long frame_count;
};
static ScreenShareAppRunData *run_data = NULL;

// ------------------------- 初始化数据 -------------------------
int initdata() {
    run_data = (ScreenShareAppRunData*)malloc(sizeof(ScreenShareAppRunData));
    if (!run_data) return -1;
    memset(run_data, 0, sizeof(ScreenShareAppRunData));

    run_data->displayBufWithDma[0] = (uint16_t*)heap_caps_malloc(IMG_W * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);
    run_data->displayBufWithDma[1] = (uint16_t*)heap_caps_malloc(IMG_W * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);
    if (!run_data->displayBufWithDma[0] || !run_data->displayBufWithDma[1]) {
        free(run_data);
        return -1;
    }

    run_data->dmaBufferSel = false;
    run_data->frame_count = 0;
    return 0;
}

// ------------------------- UDP 接收任务 -------------------------
void udpReceiverTask(void *parameter) {
    while (1) {
        int packetSize = udp.parsePacket();
        if (packetSize <= 0) {
            vTaskDelay(1 / portTICK_PERIOD_MS);
            continue;
        }

        uint8_t header[6];
        if (udp.read(header, 6) != 6) continue;

        uint16_t frame_id   = (header[0] << 8) | header[1];
        uint16_t y_start    = (header[2] << 8) | header[3];
        uint16_t line_count = (header[4] << 8) | header[5];

        if (line_count == 0 || line_count > RGB_LINE_BATCH) {
            udp.flush();
            continue;
        }

        uint32_t expected_size = IMG_W * line_count * 2;
        uint16_t buf[RGB_LINE_BATCH * IMG_W];

        int dataLen = udp.read((uint8_t*)buf, expected_size);
        if (dataLen != expected_size) continue;

        // byteswap
        for (int i = 0; i < IMG_W * line_count; i++) {
            uint16_t c = buf[i];
            buf[i] = (c << 8) | (c >> 8);
        }

        // 写入当前缓冲区
        uint8_t bufIndex = currentBuf;
        FrameData* f = &frameBuffers[bufIndex];
        f->y_start = y_start;
        f->line_count = line_count;
        memcpy(f->lines, buf, expected_size);

        frameReady[bufIndex] = true;
        currentBuf = !currentBuf; // 切换缓冲区
    }
}
// 缩放函数：将120像素行扩展到240像素
void scaleLine120to240(uint16_t* src, uint16_t* dst) {
    // 方法1：简单复制（每个像素重复一次）
    for (int i = 0; i < 120; i++) {
        dst[i * 2] = src[i];
        dst[i * 2 + 1] = src[i];
    }
    
    // 方法2：插值平滑（可选）
    /*
    for (int i = 0; i < 240; i++) {
        int srcIdx = i / 2;
        int nextIdx = (srcIdx < 119) ? srcIdx + 1 : srcIdx;
        
        if (i % 2 == 0) {
            dst[i] = src[srcIdx];
        } else {
            // 简单的线性插值
            dst[i] = blendColors(src[srcIdx], src[nextIdx], 0.5);
        }
    }
    */
}
// ------------------------- 显示任务 -------------------------
void draw_frame_task() {
    for (uint8_t i = 0; i < 2; i++) {
        if (frameReady[i]) {
            FrameData* f = &frameBuffers[i];
            uint16_t* dmaBuf = run_data->displayBufWithDma[run_data->dmaBufferSel];

            tft->dmaWait();  // 等待上一帧DMA完成
            tft->startWrite();
           // 逐行处理并显示
            for (int line = 0; line < f->line_count; line++) {
                // 获取当前源数据行
                uint16_t* srcLine = &f->lines[line * IMG_W];
                
                // 获取当前DMA缓冲区（双缓冲切换）
                uint16_t* dmaBuf = run_data->displayBufWithDma[run_data->dmaBufferSel];
                
                // 将120像素行缩放为240像素（使用两个缓冲区交替处理）
                scaleLine120to240(srcLine, dmaBuf);
                
                // 计算显示位置
                int displayY = (f->y_start + line) * 2;
                
                // 显示第一行（放大后的行）
                tft->pushImageDMA(
                    0,
                    displayY,
                    240,  // 放大后的宽度
                    1,    // 单行
                    dmaBuf,
                    dmaBuf  // 使用同一缓冲区
                );
                
                // 等待DMA完成
                tft->dmaWait();
                
                // 显示第二行（重复同一行，实现垂直放大）
                tft->pushImageDMA(
                    0,
                    displayY + 1,
                    240, 1,
                    dmaBuf,
                    dmaBuf
                );
                
                // 等待DMA完成
                tft->dmaWait();
                
                // 切换DMA缓冲区
                run_data->dmaBufferSel = !run_data->dmaBufferSel;
            }
            tft->endWrite();

            run_data->dmaBufferSel = !run_data->dmaBufferSel;
            frameReady[i] = false;
            run_data->frame_count++;
        }
    }
}

// ------------------------- Arduino setup -------------------------
void setup() {
    Serial.begin(115200);

    // 连接WiFi
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected!");

    initdata();

    // 启动UDP
    udp.begin(UDP_PORT);
    Serial.printf("UDP listening on port %d\n", UDP_PORT);

    // 初始化屏幕
    screen.init(4,100);
    tft->initDMA();
    tft->setSwapBytes(false);
    tft->fillScreen(TFT_RED);
    delay(500);
    tft->fillScreen(TFT_GREEN);
    delay(500);
    tft->fillScreen(TFT_BLUE);
    delay(500);

    screen_share_gui_init();
    display_screen_share(
        "Screen Share",
        WiFi.localIP().toString().c_str(),
        "8081",
        "Wait connect ....",
        LV_SCR_LOAD_ANIM_NONE
    );

    // 创建UDP接收任务
    xTaskCreatePinnedToCore(
        udpReceiverTask,
        "UDP Receiver",
        10240*6+4096,
        NULL,
        1,
        NULL,
        0
    );
}

// ------------------------- Arduino loop -------------------------
void loop() {
    screen.routine();

    // 绘制最新帧
    draw_frame_task();

    static unsigned long lastTime = 0;
    if (millis() - lastTime > 5000) {
        lastTime = millis();
        Serial.printf("Main loop running. Free heap: %d bytes, frames: %lu\n",
                      ESP.getFreeHeap(),
                      run_data->frame_count);
    }
}
