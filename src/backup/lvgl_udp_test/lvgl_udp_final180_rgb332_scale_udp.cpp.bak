#include <WiFi.h>
#include <WiFiUdp.h>
#include "common.h"

// ================= WiFi =================
const char* ssid     = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;
WiFiUDP udp;
#define UDP_PORT 8888

// ================= Image =================
#define SRC_W 180
#define SRC_H 180

#define DST_W 240
#define DST_H 240

#define RGB_LINE_BATCH 8

// 180 -> 240，放大比例 4/3
#define SCALE_RATIO 4
#define SCALE_DIV   3

// 计算放大后的行数
#define SCALED_LINES(line_count) ((line_count * SCALE_RATIO + SCALE_DIV - 1) / SCALE_DIV)

// ================= Frame Buffer =================
#define FRAME_BUF_COUNT 8

enum BufState {
    BUF_FREE,
    BUF_FILLING,
    BUF_READY,
    BUF_DISPLAYING
};

struct FrameData {
    uint16_t dst_y_start;     // 目标图像 y 起始位置
    uint16_t dst_line_count;  // 放大后的行数
    uint16_t lines[DST_W * SCALED_LINES(RGB_LINE_BATCH)]; // RGB565 放大后的数据
    volatile BufState state;
};

FrameData frameBuf[FRAME_BUF_COUNT];

// ================= DMA =================
uint16_t* dmaBuf[2];
volatile uint8_t dmaSel = 0;

// ================= Stats =================
volatile uint32_t frameCount = 0;
volatile uint32_t dropCount  = 0;
volatile uint32_t udpPackets = 0;

// ================= Utils =================

// RGB332 -> RGB565
static inline uint16_t rgb332_to_rgb565(uint8_t c) {
    return ((c & 0xE0) << 8) |   // R: 3 → 5
           ((c & 0x1C) << 6) |   // G: 3 → 6
           ((c & 0x03) << 3);    // B: 2 → 5
}

// 水平方向放大：从180放大到240
static inline void scale_horizontal(const uint8_t* src, uint16_t* dst) {
    for (int x = 0; x < DST_W; x++) {
        // 使用整数运算进行线性插值
        int src_x = (x * SCALE_DIV) / SCALE_RATIO;
        dst[x] = rgb332_to_rgb565(src[src_x]);
    }
}

// 垂直方向放大：通过行复制实现
static inline void scale_vertical(const uint8_t* src_lines, uint16_t* dst_lines, 
                                  uint16_t src_line_count, uint16_t* dst_line_count) {
    uint16_t scaled_count = SCALED_LINES(src_line_count);
    *dst_line_count = scaled_count;
    
    for (int dst_y = 0; dst_y < scaled_count; dst_y++) {
        // 计算源行索引
        int src_y = (dst_y * SCALE_DIV) / SCALE_RATIO;
        if (src_y >= src_line_count) src_y = src_line_count - 1;
        
        const uint8_t* src_line = src_lines + src_y * SRC_W;
        uint16_t* dst_line = dst_lines + dst_y * DST_W;
        
        scale_horizontal(src_line, dst_line);
    }
}

// ================= UDP Receiver Task =================
void udpReceiverTask(void* param) {
    uint8_t src_buf[SRC_W * RGB_LINE_BATCH]; // 临时存储原始数据
    
    while (1) {
        int packetSize = udp.parsePacket();
        if (packetSize <= 0) {
            vTaskDelay(1);
            continue;
        }
        udpPackets++;
        
        uint8_t header[6];
        if (udp.read(header, 6) != 6) {
            udp.flush();
            continue;
        }

        uint16_t y_start    = (header[2] << 8) | header[3];
        uint16_t line_count = (header[4] << 8) | header[5];

        if (line_count == 0 || line_count > RGB_LINE_BATCH) {
            udp.flush();
            continue;
        }

        // 读取原始RGB332数据
        uint32_t expect = SRC_W * line_count;
        if (udp.read(src_buf, expect) != expect) {
            udp.flush();
            continue;
        }

        // 寻找空闲缓冲区
        FrameData* f = nullptr;
        for (int i = 0; i < FRAME_BUF_COUNT; i++) {
            if (frameBuf[i].state == BUF_FREE) {
                f = &frameBuf[i];
                f->state = BUF_FILLING;
                break;
            }
        }

        if (!f) {
            dropCount++;
            continue;
        }

        // 在UDP线程中执行放大操作
        f->dst_y_start = (y_start * SCALE_RATIO) / SCALE_DIV;
        scale_vertical(src_buf, f->lines, line_count, &f->dst_line_count);
        
        f->state = BUF_READY;
    }
}

// ================= Draw Frame =================
void drawFrame() {
    FrameData* f = nullptr;

    // 寻找就绪的缓冲区
    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        if (frameBuf[i].state == BUF_READY) {
            f = &frameBuf[i];
            break;
        }
    }

    if (!f) return;
    
    f->state = BUF_DISPLAYING;

    // 等待当前DMA传输完成
    tft->dmaWait();
    
    uint8_t nextDma = dmaSel ^ 1;
    
    // 检查目标行范围是否有效
    if (f->dst_y_start + f->dst_line_count > DST_H) {
        f->dst_line_count = DST_H - f->dst_y_start;
    }
    
    if (f->dst_line_count == 0) {
        f->state = BUF_FREE;
        return;
    }

    // 计算需要复制多少数据到DMA缓冲区
    uint32_t pixels_needed = DST_W * f->dst_line_count;
    
    // 如果数据能直接放入DMA缓冲区，使用pushImageDMA
    if (pixels_needed <= DST_W * SCALED_LINES(RGB_LINE_BATCH)) {
        // 直接使用放大后的数据
        tft->startWrite();
        tft->pushImageDMA(
            0,
            f->dst_y_start,
            DST_W,
            f->dst_line_count,
            f->lines
        );
        tft->endWrite();
    } else {
        // 如果太大，分块复制到DMA缓冲区
        for (uint16_t y_offset = 0; y_offset < f->dst_line_count; y_offset += SCALED_LINES(RGB_LINE_BATCH)) {
            uint16_t lines_to_copy = min(SCALED_LINES(RGB_LINE_BATCH), f->dst_line_count - y_offset);
            
            // 复制到DMA缓冲区
            memcpy(dmaBuf[nextDma], 
                   f->lines + y_offset * DST_W, 
                   lines_to_copy * DST_W * sizeof(uint16_t));
            
            tft->startWrite();
            tft->pushImageDMA(
                0,
                f->dst_y_start + y_offset,
                DST_W,
                lines_to_copy,
                dmaBuf[nextDma]
            );
            tft->endWrite();
            
            tft->dmaWait();
        }
    }

    dmaSel = nextDma;
    f->state = BUF_FREE;
    frameCount++;
}

// ================= Setup =================
void setup() {
    Serial.begin(115200);

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(300);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected");

    udp.begin(UDP_PORT);

    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        frameBuf[i].state = BUF_FREE;
        // 预分配内存
        memset(frameBuf[i].lines, 0, sizeof(frameBuf[i].lines));
    }

    screen.init(4, 100);
    tft->initDMA();
    tft->fillScreen(TFT_BLACK);
    tft->setSwapBytes(true);

    dmaBuf[0] = (uint16_t*)heap_caps_malloc(
        DST_W * SCALED_LINES(RGB_LINE_BATCH) * sizeof(uint16_t),
        MALLOC_CAP_DMA
    );
    dmaBuf[1] = (uint16_t*)heap_caps_malloc(
        DST_W * SCALED_LINES(RGB_LINE_BATCH) * sizeof(uint16_t),
        MALLOC_CAP_DMA
    );

    if (!dmaBuf[0] || !dmaBuf[1]) {
        Serial.println("DMA alloc failed");
        while (1);
    }

    xTaskCreatePinnedToCore(
        udpReceiverTask,
        "udp_rx",
        12288,  // 增加堆栈大小
        nullptr,
        2,
        nullptr,
        0
    );
}

// ================= Debug Info =================
void printDebugInfo() {
    static uint32_t lastPrint = 0;
    uint32_t now = millis();
    
    if (now - lastPrint > 1000) {
        lastPrint = now;
        
        Serial.printf("内存: %u, ", ESP.getFreeHeap());
        Serial.printf("UDP包/秒: %u, ", udpPackets);
        Serial.printf("丢包数: %u, ", dropCount);
        Serial.printf("显示帧数: %u, ", frameCount);
        
        // 显示缓冲区状态
        Serial.print("缓冲区状态: ");
        int ready_count = 0, free_count = 0;
        for (int i = 0; i < FRAME_BUF_COUNT; i++) {
            switch(frameBuf[i].state) {
                case BUF_FREE: free_count++; break;
                case BUF_READY: ready_count++; break;
            }
        }
        Serial.printf("就绪:%d 空闲:%d", ready_count, free_count);
        Serial.println();
        
        udpPackets = 0;
    }
}

// ================= Loop =================
void loop() {
    drawFrame();
    printDebugInfo();
}