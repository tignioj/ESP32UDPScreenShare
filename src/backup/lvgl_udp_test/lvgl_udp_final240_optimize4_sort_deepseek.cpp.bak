#include <WiFi.h>
#include <WiFiUdp.h>
#include <cstring>
#include "common.h"

// ================= WiFi =================
const char* ssid = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;

WiFiUDP udp;
#define UDP_PORT 8888

// ================= Image =================
#define IMG_W 240
#define RGB_LINE_BATCH 3

// ================= Frame Buffer =================
#define FRAME_BUF_COUNT 16

enum BufState {
    BUF_FREE,
    BUF_FILLING,
    BUF_READY,
    BUF_DISPLAYING
};

struct FrameData {
    uint16_t y_start;
    uint16_t line_count;
    uint16_t lines[RGB_LINE_BATCH * IMG_W];
    volatile BufState state;
    
    bool operator<(const FrameData& other) const {
        return y_start < other.y_start;
    }
    
    bool operator==(const FrameData& other) const {
        return y_start == other.y_start;
    }
};

class SortedRingBuffer {
private:
    FrameData* buffer;
    volatile uint8_t head;
    volatile uint8_t tail;
    volatile uint8_t ready_count;
    volatile uint8_t free_count;
    uint8_t capacity;
    
    int8_t findInsertPosition(uint16_t y_start) {
        if (ready_count == 0) return -1;
        
        int8_t left = tail;
        int8_t right = (tail + ready_count - 1) % capacity;
        
        while (left != right) {
            int8_t mid = (left + (right - left) / 2) % capacity;
            if (buffer[mid].y_start > y_start) {
                right = mid;
            } else {
                left = (mid + 1) % capacity;
            }
        }
        
        return (buffer[left].y_start > y_start) ? left : -1;
    }
    
public:
    SortedRingBuffer(uint8_t size) : capacity(size), head(0), tail(0), 
                                     ready_count(0), free_count(size) {
        buffer = new FrameData[size];
        for (uint8_t i = 0; i < size; i++) {
            buffer[i].state = BUF_FREE;
        }
    }
    
    ~SortedRingBuffer() {
        delete[] buffer;
    }
    
    // 获取下一个空闲缓冲区
    FrameData* getFreeBuffer() {
        if (free_count == 0) return nullptr;
        
        for (uint8_t i = 0; i < capacity; i++) {
            uint8_t idx = (head + i) % capacity;
            if (buffer[idx].state == BUF_FREE) {
                buffer[idx].state = BUF_FILLING;
                free_count--;
                return &buffer[idx];
            }
        }
        return nullptr;
    }
    
    // 插入已填充的缓冲区（按y_start自动排序）
    bool insertSorted(FrameData* frame) {
        if (frame->state != BUF_FILLING) return false;
        
        if (ready_count == 0) {
            frame->state = BUF_READY;
            ready_count++;
            return true;
        }
        
        int8_t insert_pos = findInsertPosition(frame->y_start);
        
        if (insert_pos == -1) {
            frame->state = BUF_READY;
            ready_count++;
            return true;
        }
        
        uint8_t dest = (insert_pos + 1) % capacity;
        if (dest == head) {
            frame->state = BUF_FREE;
            free_count++;
            return false;
        }
        
        uint8_t src = insert_pos;
        while (src != head) {
            uint8_t prev = (src - 1 + capacity) % capacity;
            buffer[src] = buffer[prev];
            src = prev;
        }
        
        buffer[insert_pos] = *frame;
        buffer[insert_pos].state = BUF_READY;
        ready_count++;
        
        return true;
    }
    
    // 获取下一个待显示的帧（按y_start顺序）
    FrameData* getNextDisplayFrame() {
        if (ready_count == 0) return nullptr;
        
        uint8_t idx = tail;
        if (buffer[idx].state == BUF_READY) {
            buffer[idx].state = BUF_DISPLAYING;
            return &buffer[idx];
        }
        
        return nullptr;
    }
    
    // 释放已显示的帧
    void freeDisplayedFrame(FrameData* frame) {
        if (frame->state == BUF_DISPLAYING) {
            frame->state = BUF_FREE;
            free_count++;
            tail = (tail + 1) % capacity;
            ready_count--;
        }
    }
    
    // 回滚填充失败的帧（用于错误处理）
    void rollbackFill(FrameData* frame) {
        if (frame->state == BUF_FILLING) {
            frame->state = BUF_FREE;
            free_count++;
        }
    }
    
    uint8_t getReadyCount() const {
        return ready_count;
    }
    
    uint8_t getFreeCount() const {
        return free_count;
    }
    
    void clearAll() {
        for (uint8_t i = 0; i < capacity; i++) {
            buffer[i].state = BUF_FREE;
        }
        head = tail = 0;
        ready_count = 0;
        free_count = capacity;
    }
};

SortedRingBuffer frameBuffer(FRAME_BUF_COUNT);

// ================= DMA =================
uint16_t* dmaBuf[2];
volatile uint8_t dmaSel = 0;

// ================= Stats =================
volatile uint32_t frameCount = 0;
volatile uint32_t dropCount  = 0;
volatile uint32_t udpPackets = 0;

// ================= Utils =================
static inline uint16_t bswap16(uint16_t v) {
    return (v << 8) | (v >> 8);
}

// ================= UDP Receiver Task =================
void udpReceiverTask(void* param) {
    while (1) {
        int packetSize = udp.parsePacket();
        if (packetSize <= 0) {
            vTaskDelay(1);
            continue;
        }
        udpPackets++;
        
        uint8_t header[6];
        if (udp.read(header, 6) != 6) continue;

        uint16_t y_start    = (header[2] << 8) | header[3];
        uint16_t line_count = (header[4] << 8) | header[5];

        if (line_count == 0 || line_count > RGB_LINE_BATCH) {
            udp.flush();
            continue;
        }

        uint32_t expect = IMG_W * line_count * 2;

        // 获取空闲缓冲区
        FrameData* f = frameBuffer.getFreeBuffer();
        if (!f) {
            dropCount++;
            udp.flush();
            Serial.println("没有空闲的FrameBuffer");
            continue;
        }

        if (udp.read((uint8_t*)f->lines, expect) != expect) {
            frameBuffer.rollbackFill(f);  // 使用公共方法回滚
            continue;
        }

        // 字节序转换（如果需要）
        // for (uint32_t i = 0; i < IMG_W * line_count; i++) {
        //     f->lines[i] = bswap16(f->lines[i]);
        // }

        f->y_start = y_start;
        f->line_count = line_count;
        
        // 插入到排序缓冲区
        if (!frameBuffer.insertSorted(f)) {
            dropCount++;
            Serial.println("插入缓冲区失败");
        }
    }
}

// ================= Draw Frame =================
void drawFrame() {
    FrameData* frame = frameBuffer.getNextDisplayFrame();
    if (!frame) return;

    uint8_t nextDma = dmaSel ^ 1;

    tft->dmaWait();

    memcpy(
        dmaBuf[nextDma],
        frame->lines,
        IMG_W * frame->line_count * 2
    );

    tft->startWrite();
    tft->pushImageDMA(
        0,
        frame->y_start,
        IMG_W,
        frame->line_count,
        dmaBuf[nextDma]
    );
    tft->endWrite();

    dmaSel = nextDma;
    
    frameBuffer.freeDisplayedFrame(frame);
    frameCount++;
}

// ================= 调试输出 =================
void printDebugInfo() {
    static uint32_t lastPrint = 0;
    uint32_t now = millis();
    
    if (now - lastPrint > 1000) {
        lastPrint = now;
        
        Serial.printf("内存: %u, ", ESP.getFreeHeap());
        Serial.printf("UDP包/秒: %u, ", udpPackets);
        Serial.printf("丢包数: %u, ", dropCount);
        Serial.printf("显示帧数: %u, ", frameCount);
        Serial.printf("就绪帧: %u, 空闲帧: %u", 
                     frameBuffer.getReadyCount(), 
                     frameBuffer.getFreeCount());
        
        Serial.println();
        
        udpPackets = 0;
    }
}

// ================= Setup =================
void setup() {
    Serial.begin(115200);

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(300);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected");

    udp.begin(UDP_PORT);

    screen.init(4, 100);
    tft->initDMA();
    tft->setSwapBytes(true);

    dmaBuf[0] = (uint16_t*)heap_caps_malloc(
        IMG_W * RGB_LINE_BATCH * 2,
        MALLOC_CAP_DMA
    );
    dmaBuf[1] = (uint16_t*)heap_caps_malloc(
        IMG_W * RGB_LINE_BATCH * 2,
        MALLOC_CAP_DMA
    );

    if (!dmaBuf[0] || !dmaBuf[1]) {
        Serial.println("DMA alloc failed");
        while (1);
    }

    xTaskCreatePinnedToCore(
        udpReceiverTask,
        "udp_rx",
        8192,
        nullptr,
        2,
        nullptr,
        0
    );
    
    tft->fillScreen(TFT_BLACK);
    
    Serial.println("系统初始化完成");
}

// ================= Loop =================
void loop() {
    drawFrame();
    printDebugInfo();
}