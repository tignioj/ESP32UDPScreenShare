#include <WiFi.h>
#include <WiFiUdp.h>
#include "common.h"

// ================= WiFi =================
const char* ssid = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;

WiFiUDP udp;
#define UDP_PORT 8888

// ================= Image =================
#define IMG_W 240
#define RGB_LINE_BATCH 3

// ================= Frame Buffer =================
#define FRAME_BUF_COUNT 12

enum BufState {
    BUF_FREE,
    BUF_FILLING,
    BUF_READY,
    BUF_DISPLAYING
};

struct FrameData {
    uint16_t y_start;
    uint16_t line_count;
    uint16_t lines[RGB_LINE_BATCH * IMG_W];
    volatile BufState state;
};

// --------- Frame Pool ----------
FrameData framePool[FRAME_BUF_COUNT];

// --------- FREE 栈 ----------
uint8_t freeStack[FRAME_BUF_COUNT];
volatile uint8_t freeTop = 0;

// --------- READY 有序表（存 index）----------
uint8_t readyList[FRAME_BUF_COUNT];
volatile uint8_t readyCount = 0;

// ================= DMA =================
uint16_t* dmaBuf[2];
volatile uint8_t dmaSel = 0;

// ================= Stats =================
volatile uint32_t frameCount = 0;
volatile uint32_t dropCount  = 0;
volatile uint32_t udpPackets = 0;

// ================= Utils =================
static inline uint16_t bswap16(uint16_t v) {
    return (v << 8) | (v >> 8);
}

// ================= READY 插入（按 y_start 排序） =================
static inline void insertReady(uint8_t idx) {
    uint16_t y = framePool[idx].y_start;
    int i = readyCount;

    // 从后向前插入（小数组，代价极低）
    while (i > 0) {
        uint8_t prev = readyList[i - 1];
        if (framePool[prev].y_start <= y) break;
        readyList[i] = readyList[i - 1];
        i--;
    }

    readyList[i] = idx;
    readyCount++;
}

// ================= READY 弹出最小 y =================
static inline int popReady() {
    if (readyCount == 0) return -1;
    uint8_t idx = readyList[0];
    readyCount--;
    for (int i = 0; i < readyCount; i++) {
        readyList[i] = readyList[i + 1];
    }
    return idx;
}

// ================= UDP Receiver Task =================
void udpReceiverTask(void* param) {
    while (1) {
        int packetSize = udp.parsePacket();
        if (packetSize <= 0) {
            vTaskDelay(1);
            continue;
        }

        udpPackets++;

        uint8_t header[6];
        if (udp.read(header, 6) != 6) continue;

        uint16_t y_start    = (header[2] << 8) | header[3];
        uint16_t line_count = (header[4] << 8) | header[5];

        if (line_count == 0 || line_count > RGB_LINE_BATCH) {
            udp.flush();
            continue;
        }

        uint32_t expect = IMG_W * line_count * 2;

        // --------- 申请 FREE buffer（O(1)）---------
        if (freeTop == 0) {
            dropCount++;
            udp.flush();
            continue;
        }

        uint8_t idx = freeStack[--freeTop];
        FrameData* f = &framePool[idx];
        f->state = BUF_FILLING;

        if (udp.read((uint8_t*)f->lines, expect) != expect) {
            f->state = BUF_FREE;
            freeStack[freeTop++] = idx;
            continue;
        }

        f->y_start    = y_start;
        f->line_count = line_count;
        f->state      = BUF_READY;

        // --------- 插入 READY（自动按 y 排序）---------
        insertReady(idx);
    }
}

// ================= Draw Frame =================
void drawFrame() {
    int idx = popReady();
    if (idx < 0) return;

    FrameData* f = &framePool[idx];
    f->state = BUF_DISPLAYING;

    uint8_t nextDma = dmaSel ^ 1;
    tft->dmaWait();

    memcpy(
        dmaBuf[nextDma],
        f->lines,
        IMG_W * f->line_count * 2
    );

    tft->startWrite();
    tft->pushImageDMA(
        0,
        f->y_start,
        IMG_W,
        f->line_count,
        dmaBuf[nextDma]
    );
    tft->endWrite();

    dmaSel = nextDma;

    f->state = BUF_FREE;
    freeStack[freeTop++] = idx;

    frameCount++;
}

// ================= 调试输出 =================
void printDebugInfo() {
    static uint32_t lastPrint = 0;
    uint32_t now = millis();

    if (now - lastPrint > 1000) {
        lastPrint = now;

        Serial.printf("内存:%u UDP/s:%u 丢:%u 显:%u ",
            ESP.getFreeHeap(),
            udpPackets,
            dropCount,
            frameCount
        );

        Serial.print("READY:");
        Serial.print(readyCount);
        Serial.print(" FREE:");
        Serial.print(freeTop);
        Serial.println();

        udpPackets = 0;
    }
}

// ================= Setup =================
void setup() {
    Serial.begin(115200);

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(300);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected");

    udp.begin(UDP_PORT);

    // 初始化 FREE 栈
    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        framePool[i].state = BUF_FREE;
        freeStack[i] = i;
    }
    freeTop = FRAME_BUF_COUNT;

    screen.init(4, 100);
    tft->initDMA();
    tft->setSwapBytes(true);

    dmaBuf[0] = (uint16_t*)heap_caps_malloc(
        IMG_W * RGB_LINE_BATCH * 2,
        MALLOC_CAP_DMA
    );
    dmaBuf[1] = (uint16_t*)heap_caps_malloc(
        IMG_W * RGB_LINE_BATCH * 2,
        MALLOC_CAP_DMA
    );

    if (!dmaBuf[0] || !dmaBuf[1]) {
        Serial.println("DMA alloc failed");
        while (1);
    }

    xTaskCreatePinnedToCore(
        udpReceiverTask,
        "udp_rx",
        8192,
        nullptr,
        2,
        nullptr,
        0
    );

    tft->fillScreen(TFT_BLACK);
}

// ================= Loop =================
void loop() {
    drawFrame();
    printDebugInfo();
}
