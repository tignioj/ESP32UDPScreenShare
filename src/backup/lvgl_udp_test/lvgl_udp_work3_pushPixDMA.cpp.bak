#include <WiFi.h>
#include <WiFiUdp.h>
#include "common.h"
#include "screen_share_gui.h"

// WiFi配置
const char* ssid     = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;

WiFiUDP udp;
#define UDP_PORT 8888
#define RGB_LINE_BATCH 6   // 每次接收行数

// 图像参数
#define IMG_W 120
#define IMG_H 120

// ------------------------- 双缓冲结构 -------------------------
struct FrameData {
    uint16_t y_start;           // 原始行索引 * 2
    uint16_t line_count;        // 放大后高度，每原行重复两行
    uint16_t lines[RGB_LINE_BATCH * 2 * IMG_W]; // 240宽，每行放大两倍
};

FrameData frameBuffers[2];       // 双缓冲区
volatile bool frameReady[2] = {false, false};
volatile uint8_t currentBuf = 0; // 0或1

// ------------------------- 全局运行数据 -------------------------
struct ScreenShareAppRunData
{
    uint16_t *displayBufWithDma[2];
    bool dmaBufferSel;
    unsigned long frame_count;
};
static ScreenShareAppRunData *run_data = NULL;

// ------------------------- 初始化数据 -------------------------
int initdata() {
    run_data = (ScreenShareAppRunData*)malloc(sizeof(ScreenShareAppRunData));
    if (!run_data) return -1;
    memset(run_data, 0, sizeof(ScreenShareAppRunData));

    run_data->displayBufWithDma[0] = (uint16_t*)heap_caps_malloc(IMG_W * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);
    run_data->displayBufWithDma[1] = (uint16_t*)heap_caps_malloc(IMG_W * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);
    if (!run_data->displayBufWithDma[0] || !run_data->displayBufWithDma[1]) {
        free(run_data);
        return -1;
    }

    run_data->dmaBufferSel = false;
    run_data->frame_count = 0;
    return 0;
}

// ------------------------- UDP 接收任务 -------------------------
void udpReceiverTask(void *parameter) {
    while (1) {
        int packetSize = udp.parsePacket();
        if (packetSize <= 0) {
            vTaskDelay(1 / portTICK_PERIOD_MS);
            continue;
        }

        uint8_t header[6];
        if (udp.read(header, 6) != 6) continue;

        uint16_t frame_id   = (header[0] << 8) | header[1];
        uint16_t y_start    = (header[2] << 8) | header[3];
        uint16_t line_count = (header[4] << 8) | header[5];

        if (line_count == 0 || line_count > RGB_LINE_BATCH) {
            udp.flush();
            continue;
        }

        uint32_t expected_size = IMG_W * line_count * 2;
        uint16_t buf[RGB_LINE_BATCH * IMG_W];

        int dataLen = udp.read((uint8_t*)buf, expected_size);
        if (dataLen != expected_size) continue;

        // byteswap
        for (int i = 0; i < IMG_W * line_count; i++) {
            uint16_t c = buf[i];
            buf[i] = (c << 8) | (c >> 8);
        }

        // 写入当前缓冲区
        uint8_t bufIndex = currentBuf;
        FrameData* f = &frameBuffers[bufIndex];
        f->y_start = y_start;
        f->line_count = line_count;
        memcpy(f->lines, buf, expected_size);

        frameReady[bufIndex] = true;
        currentBuf = !currentBuf; // 切换缓冲区
    }
}

// ------------------------- 显示任务 -------------------------
void draw_frame_task() {
    for (uint8_t i = 0; i < 2; i++) {
        if (frameReady[i]) {
            FrameData* f = &frameBuffers[i];
            uint16_t* dmaBuf = run_data->displayBufWithDma[run_data->dmaBufferSel];

            tft->dmaWait();  // 等待上一帧DMA完成
            tft->startWrite();
          // 如果有setAddrWindow和pushPixelsDMA，可以手动控制
            tft->setAddrWindow(0, f->y_start * 2, IMG_W * 2, f->line_count * 2);
            
            // 手动缩放并传输
            for (int y = 0; y < f->line_count; y++) {
                // 每行传输两次（垂直放大）
                for (int repeat = 0; repeat < 2; repeat++) {
                    for (int x = 0; x < IMG_W; x++) {
                        uint16_t pixel = f->lines[y * IMG_W + x];
                        // 每个像素传输两次（水平放大）
                        dmaBuf[x * 2] = pixel;
                        dmaBuf[x * 2 + 1] = pixel;
                    }
                    tft->pushPixelsDMA(dmaBuf, IMG_W * 2);
                }
            }
            tft->endWrite();

            run_data->dmaBufferSel = !run_data->dmaBufferSel;
            frameReady[i] = false;
            run_data->frame_count++;
        }
    }
}

// ------------------------- Arduino setup -------------------------
void setup() {
    Serial.begin(115200);

    // 连接WiFi
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected!");

    initdata();

    // 启动UDP
    udp.begin(UDP_PORT);
    Serial.printf("UDP listening on port %d\n", UDP_PORT);

    // 初始化屏幕
    screen.init(4,100);
    tft->initDMA();
    tft->setSwapBytes(false);
    tft->fillScreen(TFT_RED);
    delay(500);
    tft->fillScreen(TFT_GREEN);
    delay(500);
    tft->fillScreen(TFT_BLUE);
    delay(500);

    screen_share_gui_init();
    display_screen_share(
        "Screen Share",
        WiFi.localIP().toString().c_str(),
        "8081",
        "Wait connect ....",
        LV_SCR_LOAD_ANIM_NONE
    );

    // 创建UDP接收任务
    xTaskCreatePinnedToCore(
        udpReceiverTask,
        "UDP Receiver",
        10240*6+4096,
        NULL,
        1,
        NULL,
        0
    );
}

// ------------------------- Arduino loop -------------------------
void loop() {
    screen.routine();

    // 绘制最新帧
    draw_frame_task();

    static unsigned long lastTime = 0;
    if (millis() - lastTime > 5000) {
        lastTime = millis();
        Serial.printf("Main loop running. Free heap: %d bytes, frames: %lu\n",
                      ESP.getFreeHeap(),
                      run_data->frame_count);
    }
}
