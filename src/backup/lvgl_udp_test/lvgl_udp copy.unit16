#include <WiFi.h>
#include <WiFiUdp.h>
#include "common.h"
#include "screen_share_gui.h"
// WiFi配置
const char* ssid     = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;
static uint16_t current_frame_id = 0xFFFF;
static bool frame_active = false;

WiFiUDP udp;
#define UDP_PORT 8888
#define BUFFER_SIZE 20480
#define RGB_LINE_BATCH 2   // 一次收 4 行（可调）
// 使用更简单的结构体来节省内存
struct ScreenShareAppRunData
{
    boolean udp_start;
    boolean req_sent;
    boolean client_connected;
    
    uint8_t *recvBuf;
    uint16_t *displayBufWithDma[2];
    bool dmaBufferSel;
    boolean tftSwapStatus;
    
    unsigned long pre_wifi_alive_millis;
    unsigned long last_data_time;
    unsigned long frame_count;
    
    uint16_t *lineBuf;   // 240 * N 行

};
static ScreenShareAppRunData *run_data = NULL;

// 一、图像与协议参数（固定）
#define IMG_W 240
#define IMG_H 240
#define IMG_BYTES (IMG_W * IMG_H * 2)   // 115200

#define FRAME_HEADER 0xA5
#define MAX_PAYLOAD 1000
#define MAX_PACKETS 120   // 足够 115200 / 1000

// 二、全局缓冲与状态

static void handle_incoming_data() {
    // 检查是否有数据包
    int packetSize = udp.parsePacket();
    if (packetSize <= 0) return;
    
    static uint32_t cnt;
    if (++cnt % 100 == 0) {
        Serial.println(packetSize);
    }
    
    uint8_t header[6];
    int headerLen = udp.read(header, 6);
    if (headerLen != 6) return;

    uint16_t frame_id   = (header[0] << 8) | header[1];
    uint16_t y_start    = (header[2] << 8) | header[3];
    uint16_t line_count = (header[4] << 8) | header[5];
    
      // 第一次收到数据，或检测到新的一帧
  if (!frame_active || frame_id != current_frame_id) {
      current_frame_id = frame_id;
      frame_active = true;

      // 可选：如果你以后做整帧缓存，这里是 reset 点
      // Serial.printf("New frame start: %u\n", frame_id);
  }
  // 如果是旧帧（延迟 / 乱序包），直接丢弃
  if (frame_id != current_frame_id) {
      udp.flush();   // 丢掉剩余数据
      return;
  }

    // 检查 line_count 是否合理
    if (line_count == 0 || line_count > RGB_LINE_BATCH) {
        Serial.printf("Invalid line count: %d\n", line_count);
        udp.flush();
        return;
    }
    
    // 计算期望的数据大小
    uint32_t expected_size = 240 * line_count * 2;
      
    // 读取 RGB565 数据到 lineBuf
    int dataLen = udp.read((uint8_t*)run_data->lineBuf, expected_size);
    if (dataLen != expected_size) {
        Serial.printf("Data size mismatch: got %d, expected %d\n", dataLen, expected_size);
        return;
    }
    
    // 检查 y_start 是否在屏幕范围内
    if (y_start + line_count > IMG_H) {
        Serial.printf("Y out of range: y_start=%d, line_count=%d\n", y_start, line_count);
        return;
    }
    
    
    // 使用 DMA 显示
    uint16_t *dmaBuf = run_data->displayBufWithDma[run_data->dmaBufferSel];
    // tft->dmaWait();   // 等待上一帧 DMA 完成
    // 在打印信息中添加：
        // 每10帧打印一次状态，而不是100帧
    if (run_data->frame_count % 10 == 0) {
        Serial.printf("Frame: %lu,CFrameID: %lu, DMA buf sel: %d, Heap: %d, y_start=%d, lines=%d\n", 
                     run_data->frame_count, current_frame_id,
                     run_data->dmaBufferSel,
                     ESP.getFreeHeap(),
                     y_start,
                     line_count);
    }
    tft->startWrite();
    // tft->pushImageDMA(
    //     0,          // x
    //     y_start,    // y
    //     240,        // 宽度
    //     line_count, // 高度
    //     run_data->lineBuf,  // 数据指针
    //     dmaBuf      // DMA 缓存
    // );
    tft->pushImage(
        0,
        y_start,
        240,
        line_count,
        run_data->lineBuf
    );

    tft->endWrite();
    
    // 切换 DMA 缓冲区
    run_data->dmaBufferSel = !run_data->dmaBufferSel;
    
    // 更新时间戳
    run_data->last_data_time = millis();
    run_data->frame_count++;
}


// void onImageComplete(uint8_t* img) {
//   // RGB565 原始数据
//   // img[0..115199]

//   Serial.println("Ready to display");

//   // 示例：打印前 8 个像素
//   for (int i = 0; i < 16; i += 2) {
//     uint16_t pixel = img[i] | (img[i + 1] << 8);
//     Serial.printf("%04X ", pixel);
//   }
//   Serial.println();
// }

// void handleImagePacket(uint8_t* buf, int len) {
//   if (len < 4) return;
//   if (buf[0] != 0xA5) return;

//   uint8_t img_id = buf[1];
//   uint8_t index  = buf[2];
//   uint8_t total  = buf[3];

//   int data_len = len - 4;
//   if (data_len <= 0) return;

//   uint16_t* pixelData = (uint16_t*)(buf + 4);
//   int pixelCount = data_len / 2;

//   int startPixel = index * (MAX_PAYLOAD / 2);

//   for (int i = 0; i < pixelCount; i++) {
//     int pixelPos = startPixel + i;
//     if (pixelPos >= IMG_W * IMG_H) break;

//     int x = pixelPos % IMG_W;
//     int y = pixelPos / IMG_W;

//     // lcdDrawPixel(x, y, pixelData[i]);
//   }
// }


// 任务句柄
TaskHandle_t udpTaskHandle;
void udpReceiverTask(void *parameter) {
//   char buffer[BUFFER_SIZE];
  
  while (1) {
    handle_incoming_data();
    vTaskDelay(1 / portTICK_PERIOD_MS);
  }
}

int initdata() {
    // 分配内存 - 使用更谨慎的方式
    run_data = (ScreenShareAppRunData*)malloc(sizeof(ScreenShareAppRunData));
    if (!run_data) return -1;
    memset(run_data, 0, sizeof(ScreenShareAppRunData));

    // 分配 DMA 可用的 lineBuf
    run_data->lineBuf = (uint16_t*)heap_caps_malloc(240 * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);
    if (!run_data->lineBuf) { 
        free(run_data); 
        return -1; 
    }

    // 分配两个 DMA 缓冲区用于双缓冲显示
    run_data->displayBufWithDma[0] = (uint16_t*)heap_caps_malloc(240 * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);
    run_data->displayBufWithDma[1] = (uint16_t*)heap_caps_malloc(240 * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);
    
    if (!run_data->displayBufWithDma[0] || !run_data->displayBufWithDma[1]) {
        heap_caps_free(run_data->lineBuf);
        free(run_data);
        return -1;
    }
    
    // 初始化状态
    run_data->udp_start = 0;
    run_data->req_sent = 0;
    run_data->client_connected = false;
    run_data->dmaBufferSel = false;
    run_data->pre_wifi_alive_millis = 0;
    run_data->last_data_time = 0;
    run_data->frame_count = 0;
    
    return 0;  // 成功返回 0
}

void setup() {
  Serial.begin(115200);

  // 连接WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  
  Serial.println("\nWiFi connected!");
    initdata();
  // 启动UDP
  udp.begin(UDP_PORT);
  Serial.printf("UDP listening on port %d\n", UDP_PORT);
  
          /*** Init screen ***/
    screen.init(4,100);
    tft->fillScreen(TFT_RED);
    delay(500);
    tft->fillScreen(TFT_GREEN);
    delay(500);
    tft->fillScreen(TFT_BLUE);
    delay(500);
    screen_share_gui_init();
            display_screen_share(
            "Screen Share",
            WiFi.localIP().toString().c_str(),
            "8081",
            "Wait connect ....",
            LV_SCR_LOAD_ANIM_NONE);

  // 创建UDP接收任务
  xTaskCreatePinnedToCore(
    udpReceiverTask,    // 任务函数
    "UDP Receiver",     // 任务名称
    10240*5+4096,              // 堆栈大小
    NULL,              // 参数
    1,                 // 优先级
    &udpTaskHandle,    // 任务句柄
    0                  // 核心（0或1）
  );
}

void loop() {
  // 主循环可以处理其他任务
  static unsigned long lastTime = 0;
    screen.routine();

  if (millis() - lastTime > 5000) {
    lastTime = millis();
    Serial.printf("Main loop running. Free heap: %d bytes\n", ESP.getFreeHeap());
  }
  // delay(1000);

}