#include <WiFi.h>
#include <TJpg_Decoder.h>
#include "common.h"

// ================= WiFi =================
const char* ssid     = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;
#define TCP_PORT 8888

WiFiServer server(TCP_PORT);
WiFiClient client;

// ================= JPEG buffer =================
#define MAX_JPEG_SIZE 20480  // 每帧 JPEG 最大大小，可调
static uint8_t bufferA[MAX_JPEG_SIZE];
static uint8_t bufferB[MAX_JPEG_SIZE];

static uint8_t* currBuffer = bufferA;
static uint8_t* nextBuffer = bufferB;

// ================= Frame statistics =================
static uint32_t frameCount = 0;
static uint32_t byteCount  = 0;

// ================= TJpg callback =================
bool tft_output(int16_t x, int16_t y, uint16_t w, uint16_t h, uint16_t* bitmap) {
    if (!tft) return false;
    tft->pushImage(x, y, w, h, bitmap);
    return true;
}

// ================= SETUP =================
void setup() {
    Serial.begin(115200);
    delay(1000);

    Serial.println("\n===== ESP32 TCP MJPEG (NO PSRAM) =====");
    Serial.printf("psramFound(): %s\n", psramFound() ? "YES" : "NO");

    // ---- WiFi ----
    WiFi.setSleep(false);
    WiFi.begin(ssid, password);
    Serial.print("Connecting WiFi");
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());

    server.begin();
    server.setNoDelay(true);
    client.setNoDelay(true);
    Serial.printf("TCP server started @ %d\n", TCP_PORT);

    // ---- Screen ----
    tft_init();
    tft->initDMA();
    tft->fillScreen(TFT_BLACK);

    // ---- TJpg_Decoder ----
    TJpgDec.setJpgScale(1);
    TJpgDec.setSwapBytes(true);
    TJpgDec.setCallback(tft_output);

    Serial.println("TJpg_Decoder ready");
}

// ================= Helper: read exactly n bytes =================
bool readBytes(WiFiClient& c, uint8_t* buf, size_t len) {
    size_t received = 0;
    unsigned long start = millis();
    while (received < len) {
        if (c.available()) {
            int n = c.read(buf + received, len - received);
            if (n > 0) {
                received += n;
            }
        }
        // 超时 2 秒
        if (millis() - start > 2000) return false;
        // delay(1);
        // yield();   // 或完全删掉
    }
    return true;
}

// ================= LOOP =================
void loop() {
    // 等客户端连接
    if (!client || !client.connected()) {
        client = server.available();
        if (client) {
            Serial.println("[TCP] Client connected");
            frameCount = 0;
            byteCount  = 0;
        }
        delay(5);
        return;
    }

    // ---- 1. 读取帧长度 ----
    uint8_t lenBuf[4];
    if (!readBytes(client, lenBuf, 4)) return;
    uint32_t frameLen = ((uint32_t)lenBuf[0] << 24) |
                        ((uint32_t)lenBuf[1] << 16) |
                        ((uint32_t)lenBuf[2] << 8)  |
                        ((uint32_t)lenBuf[3]);
    if (frameLen == 0 || frameLen > MAX_JPEG_SIZE) {
        Serial.printf("[ERR] Invalid frame length %u\n", frameLen);
        client.stop();
        return;
    }

    // ---- 2. 读取完整 JPEG ----
    if (!readBytes(client, currBuffer, frameLen)) {
        Serial.println("[ERR] Timeout reading JPEG");
        client.stop();
        return;
    }
    byteCount += frameLen;

    // ---- 3. 解码并显示 ----
    if (TJpgDec.drawJpg(0, 0, currBuffer, frameLen)==JDR_OK) {
        frameCount++;
        if ((frameCount & 0x1F) == 0) { // 每32帧打印一次
            Serial.printf("[OK] Frame %lu, bytes %lu\n", frameCount, byteCount);
        }
        byteCount = 0;

        // ---- 4. 双缓冲切换 ----
        uint8_t* tmp = currBuffer;
        currBuffer = nextBuffer;
        nextBuffer = tmp;
    }
}
