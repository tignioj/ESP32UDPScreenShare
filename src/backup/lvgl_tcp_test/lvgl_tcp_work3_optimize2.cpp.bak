#include <WiFi.h>
#include <WiFiUdp.h>
#include "common.h"

// ================= WiFi =================
const char* ssid     = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;


WiFiClient client;
WiFiServer server(8888);

// ================= Image =================
#define IMG_W 240
#define RGB_LINE_BATCH 12

// ================= Frame Buffer =================
#define FRAME_BUF_COUNT 8

enum BufState {
    BUF_FREE,
    BUF_FILLING,
    BUF_READY,
    BUF_DISPLAYING
};

struct FrameData {
    uint16_t y_start;
    uint16_t line_count;
    uint16_t lines[RGB_LINE_BATCH * IMG_W];
    volatile BufState state;
};

FrameData frameBuf[FRAME_BUF_COUNT];

// ================= DMA =================
uint16_t* dmaBuf[2];
volatile uint8_t dmaSel = 0;

// ================= Stats =================
volatile uint32_t frameCount = 0;
volatile uint32_t dropCount  = 0;

// ================= Utils =================
static inline uint16_t bswap16(uint16_t v) {
    return (v << 8) | (v >> 8);
}

// ================= UDP Receiver Task =================
void tcpReceiverTask(void* param) {
    uint8_t header[6];

    while (1) {
        if (!client || !client.connected()) {
            client = server.available();
            vTaskDelay(10);
            continue;
        }

        client.setNoDelay(true);
        client.setTimeout(5);

        // header 不完整直接等
        if (client.available() < 6) {
            vTaskDelay(1);
            continue;
        }

        if (client.readBytes(header, 6) != 6) {
            continue;
        }

        uint16_t y_start    = (header[2] << 8) | header[3];
        uint16_t line_count = (header[4] << 8) | header[5];

        if (line_count == 0 || line_count > RGB_LINE_BATCH) {
            continue;
        }

        uint32_t expect = IMG_W * line_count * 2;

        // 找 FREE buffer
        FrameData* f = nullptr;
        for (int i = 0; i < FRAME_BUF_COUNT; i++) {
            if (frameBuf[i].state == BUF_FREE) {
                f = &frameBuf[i];
                f->state = BUF_FILLING;
                break;
            }
        }

        if (!f) {
            // ⚠️ 没缓冲 → 主动丢旧数据
            dropCount++;
            client.flush();   // 直接丢 backlog
            continue;
        }

        if (client.available() < expect) {
            f->state = BUF_FREE;
            continue;
        }

        if (client.readBytes((uint8_t*)f->lines, expect) != expect) {
            f->state = BUF_FREE;
            continue;
        }

        f->y_start    = y_start;
        f->line_count = line_count;
        f->state      = BUF_READY;
    }
}
// ================= Draw Frame =================
void drawFrame() {
    FrameData* newest = nullptr;
    int newestIdx = -1;

    // 找“最新 READY”的 buffer（从后往前，降低延迟）
    for (int i = FRAME_BUF_COUNT - 1; i >= 0; i--) {
        if (frameBuf[i].state == BUF_READY) {
            newest = &frameBuf[i];
            newestIdx = i;
            break;
        }
    }

    if (!newest) {
        // delay(2);
        vTaskDelay(1);
        return;
    }
    

    // 其余 READY 的直接丢弃（防堆积）
    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        if (i != newestIdx && frameBuf[i].state == BUF_READY) {
            frameBuf[i].state = BUF_FREE;
            dropCount++;
            Serial.printf("丢弃堆积的帧%d\n", i);
        }
    }

    newest->state = BUF_DISPLAYING;

    uint8_t nextDma = dmaSel ^ 1;

    // 只在切换 DMA buffer 时等待
    unsigned long dmawait = micros();

    tft->dmaWait();
    unsigned long cost = micros() - dmawait;
    if(cost > 100) Serial.printf("dmawait耗时%lu\n", micros() - dmawait);

    memcpy(
        dmaBuf[nextDma],
        newest->lines,
        IMG_W * newest->line_count * 2
    );
    tft->startWrite();
    tft->pushImageDMA(
        0,
        newest->y_start,
        IMG_W,
        newest->line_count,
        dmaBuf[nextDma]
    );
    tft->endWrite();
    
    dmaSel = nextDma;
    newest->state = BUF_FREE;
    frameCount++;
}

// ================= Setup =================
void setup() {
    Serial.begin(115200);

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(300);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected");

    server.begin();
    server.setNoDelay(true);

    for (int i = 0; i < FRAME_BUF_COUNT; i++) {
        frameBuf[i].state = BUF_FREE;
    }

    tft_init();
    tft->initDMA();
    tft->setSwapBytes(true);

    dmaBuf[0] = (uint16_t*)heap_caps_malloc(
        IMG_W * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);
    dmaBuf[1] = (uint16_t*)heap_caps_malloc(
        IMG_W * RGB_LINE_BATCH * 2, MALLOC_CAP_DMA);

    xTaskCreatePinnedToCore(
        tcpReceiverTask,
        "tcp_rx",
        8192,
        nullptr,
        2,
        nullptr,
        0
    );

    tft->fillScreen(TFT_BLACK);
}

// ================= Loop =================
void loop() {
    // screen.routine();
    drawFrame();

    static uint32_t last = 0;
    if (millis() - last > 3000) {
        last = millis();
        Serial.printf(
            "heap=%u frames=%u drop=%u\n",
            ESP.getFreeHeap(),
            frameCount,
            dropCount
        );
    }
}
