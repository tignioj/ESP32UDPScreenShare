#include <WiFi.h>
#include "common.h"

// ================= WiFi =================
const char* ssid     = WIFI_SSID_STR;
const char* password = WIFI_PASSWORD_STR;
#define TCP_PORT 8888

WiFiServer server(TCP_PORT);
WiFiClient client;

// ================= Screen & DMA =================
#define IMG_W 240
#define MAX_LINES_PER_PACKET 60   // 一次最多接收的行数
#define BUFFER_SIZE (IMG_W * MAX_LINES_PER_PACKET)  // RGB332 每像素 1 字节

uint8_t *dmaBuf[2];       // 双缓冲，接收 RGB332 数据
uint16_t *dmaBuf16;       // 转换后的 RGB565 临时缓冲
bool dmaBufSel = false;   // 当前使用的缓冲区

unsigned long last_packet_time = 0;

// ------------------------- 工具函数 -------------------------
bool readBytesWithTimeout(WiFiClient &client, uint8_t *buffer, size_t size, uint32_t timeout_ms) {
    unsigned long startTime = millis();
    size_t bytesRead = 0;
    
    while (bytesRead < size) {
        if (millis() - startTime > timeout_ms) return false;
        if (client.available() > 0) {
            bytesRead += client.read(buffer + bytesRead, size - bytesRead);
            last_packet_time = millis();
        }
        vTaskDelay(1 / portTICK_PERIOD_MS);
    }
    return true;
}

// ------------------------- RGB332 转 RGB565 -------------------------
inline uint16_t rgb332_to_rgb565(uint8_t c) {
    uint8_t r3 = (c >> 5) & 0x07;
    uint8_t g3 = (c >> 2) & 0x07;
    uint8_t b2 = c & 0x03;

    uint16_t r5 = (r3 << 2) | (r3 >> 1);  // 3->5位
    uint16_t g6 = (g3 << 3) | (g3 >> 0);  // 3->6位
    uint16_t b5 = (b2 << 3) | (b2 << 1) | (b2 >> 1); // 2->5位

    return (r5 << 11) | (g6 << 5) | b5;
}

// ================= SETUP =================
void setup() {
    Serial.begin(115200);
    delay(1000);

    Serial.println("\n===== ESP32 MJPEG STREAM RGB332 (NO PSRAM) =====");
    Serial.printf("psramFound(): %s\n", psramFound() ? "YES" : "NO");

    // ---- WiFi ----
    WiFi.setSleep(false);
    WiFi.begin(ssid, password);
    Serial.print("Connecting WiFi");
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());

    server.begin();
    server.setNoDelay(true);
    Serial.printf("TCP server started @ %d\n", TCP_PORT);

    // ---- Screen ----
    tft_init();
    tft->initDMA();
    tft->setSwapBytes(true);
    tft->fillScreen(TFT_BLACK);

    // ---- 双缓冲分配 ----
    dmaBuf[0] = (uint8_t*)heap_caps_malloc(BUFFER_SIZE, MALLOC_CAP_DMA);
    dmaBuf[1] = (uint8_t*)heap_caps_malloc(BUFFER_SIZE, MALLOC_CAP_DMA);
    dmaBuf16   = (uint16_t*)heap_caps_malloc(IMG_W * MAX_LINES_PER_PACKET * sizeof(uint16_t), MALLOC_CAP_DMA);

    if (!dmaBuf[0] || !dmaBuf[1] || !dmaBuf16) {
        Serial.println("Failed to allocate DMA buffers!");
        while(1);
    }
}

// ================= LOOP =================
void loop() {
    if (!client || !client.connected()) {
        client = server.available();
        if (client) Serial.println("[TCP] Client connected");
        delay(5);
        return;
    }

    if (!client.available()) {
        delay(1);
        return;
    }

    // ---- 读取 6 字节包头 ----
    uint8_t header[6];
    if (client.read(header, 6) != 6) return;

    uint16_t frame_id   = (header[0] << 8) | header[1];
    uint16_t y_start    = (header[2] << 8) | header[3];
    uint16_t line_count = (header[4] << 8) | header[5];

    if (line_count == 0 || line_count > MAX_LINES_PER_PACKET) {
        client.stop();
        return;
    }

    if(frame_id %1000 ==0)  Serial.printf("fid=%d, y=%d, count=%d\n", frame_id, y_start, line_count);

    // ---- 指定 DMA 缓冲区接收数据 ----
    uint8_t* currentBuf = dmaBuf[dmaBufSel];
    uint32_t expected_size = IMG_W * line_count;

    if (!readBytesWithTimeout(client, currentBuf, expected_size, 200)) {
        Serial.println("Data read timeout, disconnecting client");
        client.stop();
        return;
    }

    // ---- RGB332 -> RGB565 转换 ----
    unsigned long before_transfer = millis();
    for (uint32_t i = 0; i < IMG_W * line_count; i++) {
        dmaBuf16[i] = rgb332_to_rgb565(currentBuf[i]);
    }

    // ---- 等待上一次 DMA 完成 ----
    tft->dmaWait();

    // ---- DMA 输出 ----
    tft->startWrite();
    tft->pushImageDMA(0, y_start, IMG_W, line_count, dmaBuf16, dmaBuf16);
    tft->endWrite();

    // ---- 切换缓冲区 ----
    dmaBufSel = !dmaBufSel;
}
